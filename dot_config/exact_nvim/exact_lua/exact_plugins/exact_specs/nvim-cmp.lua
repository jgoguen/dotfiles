-- Do not edit this file directly! It is managed by chezmoi.

local border_opts = {
	border = 'single',
	winhighlight = 'Normal:Normal,FloatBorder:FloatBorder,CursorLine:Visual,Search:None',
}

local M = {
	'hrsh7th/nvim-cmp',
	dependencies = {
		'hrsh7th/cmp-buffer',
		'hrsh7th/cmp-emoji',
		'hrsh7th/cmp-nvim-lsp',
		'hrsh7th/cmp-nvim-lsp-signature-help',
		'hrsh7th/cmp-path',
		'L3MON4D3/LuaSnip',
		'onsails/lspkind.nvim',
		'saadparwaiz1/cmp_luasnip',
		'windwp/nvim-autopairs',
	},
	opts = {
		autopairs = {
			check_ts = true,
			ts_config = {
				java = false,
			},
			fast_wrap = {
				map = '<M-e>',
				chars = {'{', '[', '(', '"', "'"},
				pattern = string.gsub([[ [%'%"%)%>%]%)%}%,] ]], '%s+', ''),
				offset = 0,
				end_key = '$',
				keys = 'qwertyuiopzxcvbnmasdfghjkl',
				check_comma = true,
				highlight = 'PmenuSel',
				highlight_grey = 'LineNr',
			},
		},
	},
}

function M.config(plugin)
	local cmp = require('cmp')
	local utils = require('utils')

	-- Base nvim-cmp
	cmp.setup({
		enabled = function()
			local ctx = require('cmp.config.context')

			-- Always disabled in command mode
			if vim.api.nvim_get_mode().mode == 'c' then
				return false
			end

			-- Disable in comment contexts
			return not ctx.in_treesitter_capture("comment") and not ctx.in_syntax_group("Comment")
		end,
		preselect = cmp.PreselectMode.None,
		formatting = {
			fields = { 'kind', 'abbr', 'menu' },
			format = require('lspkind').cmp_format(require('utils').lspkind_opts()),
		},
		snippet = {
			expand = function(args) require('luasnip').lsp_expand(args.body) end,
		},
		duplicates = {
			nvim_lsp = 1,
			luasnip = 1,
			cmp_tabnine = 1,
			buffer = 1,
			path = 1,
		},
		confirm_opts = {
			behavior = cmp.ConfirmBehavior.Replace,
			select = false,
		},
		window = {
			completion = cmp.config.window.bordered(border_opts),
			documentation = cmp.config.window.bordered(border_opts),
		},
		mapping = {
			['<C-Space>'] = cmp.mapping(cmp.mapping.complete(), { 'i', 'c' }),
			['<C-b>'] = cmp.mapping(cmp.mapping.scroll_docs(-4), { 'i', 'c' }),
			['<C-d>'] = cmp.mapping(cmp.mapping.scroll_docs(-1), { 'i', 'c' }),
			['<C-e>'] = cmp.mapping {
				i = cmp.mapping.abort(),
				c = cmp.mapping.close(),
			},
			['<C-f>'] = cmp.mapping(cmp.mapping.scroll_docs(4), { 'i', 'c' }),
			['<C-j>'] = cmp.mapping.select_next_item { behavior = cmp.SelectBehavior.Insert },
			['<C-k>'] = cmp.mapping.select_prev_item { behavior = cmp.SelectBehavior.Insert },
			['<C-n>'] = cmp.mapping.select_next_item { behavior = cmp.SelectBehavior.Insert },
			['<C-p>'] = cmp.mapping.select_prev_item { behavior = cmp.SelectBehavior.Insert },
			['<C-y>'] = cmp.config.disable,
			['<Esc>'] = cmp.mapping({
				i = cmp.mapping.abort(),
				c = cmp.mapping.close(),
			}),
			['<Up>'] = cmp.mapping.select_prev_item { behavior = cmp.SelectBehavior.Select },
			['<Down>'] = cmp.mapping.select_next_item { behavior = cmp.SelectBehavior.Select },
			['<CR>'] = cmp.mapping.confirm({
				behavior = cmp.ConfirmBehavior.Replace,
				select = false,
			}),
			['<Tab>'] = require('cmp').mapping(function(fallback)
				local cmp = require('cmp')
				local luasnip = require('luasnip')
				if cmp.visible() then
					cmp.select_next_item()
				elseif luasnip.expandable() then
					luasnip.expand()
				elseif luasnip.expand_or_jumpable() then
					luasnip.expand_or_jump()
				else
					fallback()
				end
			end, {
				'i',
				's',
			}),
			['<S-Tab>'] = require('cmp').mapping(function(fallback)
				local cmp = require('cmp')
				local luasnip = require('luasnip')
				if cmp.visible() then
					cmp.select_prev_item()
				elseif luasnip.jumpable(-1) then
					luasnip.jump(-1)
				else
					fallback()
				end
			end, {
				'i',
				's',
			}),
		},
	})

	-- Begin autopairs
	local autopairs = require('nvim-autopairs')
	local autopair_cmp = require('nvim-autopairs.completion.cmp')
	local autopair_rule = require('nvim-autopairs.rule')
	local autopair_cond = require('nvim-autopairs.conds')
	local handlers = require('nvim-autopairs.completion.handlers')
	autopairs.setup(plugin.opts.autopairs)

	for _, p in ipairs({',', ';'}) do
		autopairs.add_rules({
			-- Move past comma and semi-colon
			autopair_rule('', p)
				:with_move(function(opts) return opts.char == p end)
				:with_pair(function() return false end)
				:with_del(function() return false end)
				:with_cr(function() return false end)
				:use_key(p)
		})
	end

	autopairs.add_rules({
		-- Add space before equals
		autopair_rule('=', '')
			:with_pair(autopair_cond.not_inside_quote())
			:with_pair(function(opts)
				local last_char = opts.line:sub(opts.col - 1, opts.col - 1)
				if last_char:match('[%w%=%s]') then
					return true
				end
				return false
			end)
			:replace_endpair(function(opts)
				local prev_chars = opts.line:sub(opts.col - 2, opts.col - 1)
				local next_char = opts.line:sub(opts.col, opts.col)
				next_char = next_char == ' ' and '' or ' '

				if prev_chars:match('%w$') then
					return '<BS> =' .. next_char
				end
				if prev_chars:match('%=$') then
					return next_char
				end
				if prev_chars:match('=') then
					return '<BS><BS>=' .. next_char
				end

				return ''
			end)
			:set_end_pair_length(0)
			:with_move(autopair_cond.none())
			:with_del(autopair_cond.none())
	})

	cmp.event:on(
		'confirm_done',
		autopair_cmp.on_confirm_done({
			filetypes = {
				['*'] = {
					['('] = {
						kind = {
							cmp.lsp.CompletionItemKind.Function,
							cmp.lsp.CompletionItemKind.Method,
						},
						handler = handlers["*"]
					},
				},
				latex = false,
				tex = false,
			},
		})
	)
	-- End autopairs

	local sources = {
		'buffer',
		'emoji',
		'luasnip',
		'nvim_lsp',
		'nvim_lsp_signature_help',
		'path',
	}
	for _, source in ipairs(sources) do
		utils.add_cmp_source(utils.get_cmp_source(source))
	end
end

return M
