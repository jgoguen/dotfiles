-- Do not edit this file directly! It is managed by chezmoi.

local Utils = require('utils')

---@param type string
---@param node TSNode
---@return TSNode?
local function first_node_of_type(type, node)
	if node:type() == type then
		return node
	end

	for child in node:iter_children() do
		local result = first_node_of_type(type, child)
		if result then
			return result
		end
	end

	return nil
end

-- Find the first node of any given type under a node.
---@param types string[]
---@param node TSNode
---@return TSNode?
local function first_node_of_any_type(types, node)
	for _, type in ipairs(types) do
		if node:type() == type then
			return node
		end
	end

	for child in node:iter_children() do
		local result = first_node_of_any_type(types, child)
		if result then
			return result
		end
	end
end

-- Find the first block_mapping_pair node under a node.
---@param node TSNode
---@return TSNode?
local function first_block_mapping_pair(node)
	return first_node_of_type('block_mapping_pair', node)
end

-- Get the block_mapping node from the node
---@param node TSNode
---@return TSNode?
local function block_mapping_under_node(node)
	if node:type() == 'block_mapping' then
		return node
	end

	for child in node:iter_children() do
		local result = block_mapping_under_node(child)
		if result then
			return result
		end
	end

	return nil
end

-- Jump to the given node
---@param node TSNode
local function jump_to_node(node)
	local row, col = node:start()
	vim.api.nvim_win_set_cursor(0, { row + 1, col })
end

-- Get the current block mapping pair node under the cursor
---@return TSNode?
local function current_pair()
	local row, col = unpack(vim.api.nvim_win_get_cursor(0))
	local node = vim.treesitter.get_node({ pos = { row - 1, col } })
	while node do
		if node:type() == 'block_mapping_pair' then
			return node
		end
		node = node:parent()
	end

	return nil
end

-- Get the parent block mapping node of the given node
---@param node TSNode?
---@return TSNode?
local function parent_mapping(node)
	if not node then
		node = current_pair()
		if not node then
			Utils.log('parent_mapping: no current pair node found')
			return nil
		end
	end

	local parent = node:parent()
	while parent do
		if
			(parent:type() == 'block_mapping_pair' or parent:type() == 'block_sequence_item') and parent:id() ~= node:id()
		then
			return parent
		end
		parent = parent:parent()
	end

	return nil
end

-- Get the most useful node to send the cursor to based on the node type.
---@param node TSNode
---@return TSNode
local function jump_target(node)
	if node:type() == 'block_mapping_pair' then
		-- block_mapping_pair: jump to the key node if it exists
		local key_node = node:field('key')[1]
		return key_node or node
	elseif node:type() == 'block_mapping' then
		-- block_mapping: find the first block_mapping_pair and jump to its key node
		local first_pair = first_block_mapping_pair(node)
		if first_pair then
			local key_node = first_pair:field('key')[1]
			return key_node or first_pair
		end
	end

	-- For other node types, the node itself is probably the best target
	return node
end

-- Parse the path string into components. Accepts any mix of dot and bracket notation:
-- - foo.bar.baz
-- - foo[0].bar
-- - foo[bar].0[baz]
-- - foo.1.bar.0[1].baz
---@param path string
---@return string[]
local function parse_path(path)
	local components = {}

	-- Normalize path by replacing bracket notation with dot notation
	path = path:gsub('%[([^%]]+)%]', '.%1')
	for component in path:gmatch('[^.]+') do
		local n = tonumber(component)
		table.insert(components, n or component)
	end

	return components
end

-- Find the next container type node below the given node.
---@param node TSNode
---@return TSNode?
local function find_container(node)
	return first_node_of_any_type({ 'block_sequence', 'block_mapping', 'block_mapping_pair' }, node)
end

-- Find the closest ancestor of the given type
---@param type string
---@param node TSNode?
---@return TSNode?
local function closest_ancestor_of_type(type, node)
	if not node then
		node = vim.treesitter.node_at_cursor()
		if not node then
			Utils.log('closest_ancestor_of_type: no node at cursor')
			return nil
		end
	end

	local parent = node:parent()
	while parent do
		if parent:type() == type then
			return parent
		end
		parent = parent:parent()
	end

	return nil
end

---@param bufnr integer?
---@return TSNode?
local function get_root(bufnr)
	bufnr = bufnr or 0
	local parser = vim.treesitter.get_parser(bufnr, 'yaml')
	if not parser then
		Utils.log('get_root: no parser found for buffer ' .. bufnr)
		return nil
	end

	local tree = parser:parse()[1]
	if not tree then
		Utils.log('get_root: no tree found for buffer ' .. bufnr)
		return nil
	end

	return tree:root()
end

-- Find all direct children of a node with a given type
---@param type string
---@param node TSNode?
---@return TSNode[]
local function children_of_type(type, node)
	if not node then
		node = get_root()
		if not node then
			Utils.log('children_of_type: no root node found')
			return {}
		end
	end

	---@type TSNode[]
	local result = {}
	for child in node:iter_children() do
		if child:type() == type then
			table.insert(result, child)
		end
	end

	return result
end

-- Find all block mapping pair siblings of the given node
---@param node TSNode
---@return TSNode[], integer
local function sibling_pairs(node)
	local type = node:type()
	local container_type = (type == 'block_mapping_pair') and 'block_mapping' or 'block_sequence'
	local container = closest_ancestor_of_type(container_type, node)
	if not container then
		Utils.log('sibling_pairs: no container found for node type ' .. type)
		return {}, 1
	end

	local siblings = children_of_type(type, container)
	local idx = 1
	for i, sibling in ipairs(siblings) do
		if sibling:id() == node:id() then
			idx = i
			break
		end
	end

	return siblings, idx
end

-- Find a block mapping pair with the given key in a block mapping node
---@param key string
---@param node TSNode?
---@return TSNode?
local function find_pair_with_key(key, node)
	if not node then
		node = vim.treesitter.node_at_cursor()
		if not node then
			Utils.log('find_pair_with_key: no node at cursor')
			return nil
		end
	end

	for _, pair in ipairs(children_of_type('block_mapping_pair', node)) do
		local key_node = pair:field('key')[1]
		if key_node and vim.treesitter.get_node_text(key_node, 0) == key then
			return pair
		end
	end
end

-- Find a YAML node by path components
---@param path string[]
---@param node TSNode
---@return TSNode?
local function node_by_path(path, node)
	if #path == 0 then
		return node
	end

	local mapping_node = find_container(node)
	if not mapping_node then
		Utils.log('No top-level mapping or sequence found under node at path ' .. table.concat(path, '.'))
		vim.notify(
			'No top-level mapping or sequence found under node for YAML path: ' .. table.concat(path, '.'),
			vim.log.levels.WARN
		)
		return nil
	end

	---@type TSNode?
	local target_node
	for i, segment in ipairs(path) do
		local is_last = i == #path
		Utils.log(string.format('Processing path segment %d: %s (current node type: %s)', i, segment, mapping_node:type()))

		if type(segment) == 'number' then
			if mapping_node:type() ~= 'block_sequence' then
				local msg =
					string.format('Expected a sequence at path segment %d (%s), but found %s', i, segment, mapping_node:type())
				Utils.log('node_by_path: ' .. msg)
				vim.notify(msg, vim.log.levels.WARN)
				return nil
			end

			local items = children_of_type('block_sequence_item', mapping_node)
			local item = items[segment + 1] -- YAML sequences are 0-indexed, lua is 1-indexed
			if not item then
				local msg = string.format('Index %d out of bounds for sequence at path segment %d (%s)', segment, i, segment)
				Utils.log('node_by_path: ' .. msg)
				vim.notify(msg, vim.log.levels.WARN)
				return nil
			end

			target_node = item

			if not is_last then
				local next_mapping = find_container(item)
				if not next_mapping then
					local msg =
						string.format('No mapping or sequence found under sequence item at path segment %d (%s)', i, segment)
					Utils.log('node_by_path: ' .. msg)
					vim.notify(msg, vim.log.levels.WARN)
					return nil
				end
				mapping_node = next_mapping
			end
		else
			-- String key into mapping
			if mapping_node:type() ~= 'block_mapping' then
				local msg =
					string.format('Expected a mapping at path segment %d (%s), but found %s', i, segment, mapping_node:type())
				Utils.log('node_by_path: ' .. msg)
				vim.notify(msg, vim.log.levels.WARN)
				return nil
			end

			local pair = find_pair_with_key(segment, mapping_node)
			if not pair then
				local msg = string.format('No pair with key "%s" found in mapping at path segment %d', segment, i)
				Utils.log('node_by_path: ' .. msg)
				vim.notify(msg, vim.log.levels.WARN)
				return nil
			end

			target_node = pair

			if not is_last then
				local value_node = pair:field('value')[1]
				if not value_node then
					local msg = string.format('No value node found for pair with key "%s" at path segment %d', segment, i)
					Utils.log('node_by_path: ' .. msg)
					vim.notify(msg, vim.log.levels.WARN)
					return nil
				end

				local next_mapping = find_container(value_node)
				if not next_mapping then
					local msg = string.format(
						'No mapping or sequence found under value node for pair with key "%s" at path segment %d',
						segment,
						i
					)
					Utils.log('node_by_path: ' .. msg)
					vim.notify(msg, vim.log.levels.WARN)
					return nil
				end

				mapping_node = next_mapping
			end
		end
	end

	return target_node
end

local M = {}

---@param path string
function M.go_to_path(path)
	if not path or path == '' then
		path = vim.fn.input('YAML path: ')
		if not path or path == '' then
			vim.notify('No YAML path provided', vim.log.levels.WARN)
			return
		end
	end

	local keys = parse_path(path)
	if #keys == 0 then
		vim.notify('Invalid YAML path', vim.log.levels.WARN)
		return
	end

	local root = get_root()
	if not root then
		vim.notify('Could not get YAML root node', vim.log.levels.ERROR)
		return
	end

	local node = node_by_path(keys, root)
	if node then
		jump_to_node(jump_target(node))
	else
		Utils.log('go_to_path: no key node for pair at path ' .. path)
		vim.notify('Could not find key node for YAML path: ' .. path, vim.log.levels.WARN)
		return
	end
end

-- Jump to the next sibling node
function M.next_sibling()
	local pair = current_pair()
	if not pair then
		Utils.log('next_sibling: not inside a YAML mapping pair')
		vim.notify('Not inside a YAML mapping pair', vim.log.levels.WARN)
		return
	end

	Utils.log(string.format('Current node text: %s', vim.treesitter.get_node_text(pair, 0)))

	local all_siblings, idx = sibling_pairs(pair)
	local target = all_siblings[idx + 1]
	Utils.log(string.format('Found %d siblings, current index %d, target index %d', #all_siblings, idx, idx + 1))
	Utils.log(string.format('Target node text: %s', target and vim.treesitter.get_node_text(target, 0) or 'nil'))
	if target then
		jump_to_node(jump_target(target))
	else
		vim.notify('No next sibling', vim.log.levels.INFO)
	end
end

-- Jump to the previous sibling node
function M.prev_sibling()
	local pair = current_pair()
	if not pair then
		Utils.log('next_sibling: not inside a YAML mapping pair')
		vim.notify('Not inside a YAML mapping pair', vim.log.levels.WARN)
		return
	end

	local all_siblings, idx = sibling_pairs(pair)
	local target = all_siblings[idx - 1]
	if target then
		jump_to_node(jump_target(target))
	else
		vim.notify('Already at first sibling', vim.log.levels.INFO)
	end
end

-- Go up one indentation level in the YAML hierarchy
function M.go_up()
	local mapping = parent_mapping()
	while mapping do
		if mapping:type() == 'block_mapping_pair' then
			jump_to_node(jump_target(mapping))
			return
		end
		mapping = mapping:parent()
	end

	Utils.log('go_up: parent mapping has no parent pair')
	vim.notify('Already at top level', vim.log.levels.INFO)
end

-- Go to the next child key in the YAML hierarchy
function M.go_down()
	local pair = current_pair()
	if not pair then
		Utils.log('go_down: not inside a YAML mapping pair')
		vim.notify('Not inside a YAML mapping pair', vim.log.levels.WARN)
		return
	end

	-- Find the right search base node
	---@type TSNode?
	local search_root
	if pair:type() == 'block_mapping_pair' then
		search_root = pair:field('value')[1] or pair
	else
		search_root = pair
	end
	if not search_root then
		Utils.log('go_down: current pair has no value node')
		vim.notify('Current node has no value', vim.log.levels.WARN)
		return
	end

	local child_mapping = block_mapping_under_node(search_root)
	if child_mapping then
		jump_to_node(jump_target(child_mapping))
	else
		vim.notify('Current node has no child mapping', vim.log.levels.WARN)
		return
	end
end

return M
