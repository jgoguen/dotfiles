-- Do not edit this file directly! It is managed by chezmoi.

local function lsp_highlight_document(client)
	if client.server_capabilities.documentHighlightProvider then
		vim.api.nvim_create_augroup('lsp_document_highlight', { clear = true })
		vim.api.nvim_create_autocmd('CursorHold', {
			group = 'lsp_document_highlight',
			pattern = '<buffer>',
			callback = vim.lsp.buf.document_highlight,
		})
		vim.api.nvim_create_autocmd('CursorMoved', {
			group = 'lsp_document_highlight',
			pattern = '<buffer>',
			callback = vim.lsp.buf.clear_references,
		})
	end
end

local function go_to_definition(split_cmd)
	return function(_, result, ctx)
		if result == nil or vim.tbl_isempty(result) then
			return nil
		end

		vim.cmd(split_cmd and split_cmd or 'vsplit')

		if vim.tbl_islist(result) then
			vim.lsp.util.jump_to_location(result[1])

			if #result > 1 then
				vim.lsp.util.set_qflist(vim.lsp.util.locations_to_items(result))
				vim.api.nvim_command('copen')
				vim.api.nvim_command('wincmd p')
			end
		else
			vim.lsp.util.jump_to_location(result)
		end
	end
end

vim.lsp.handlers['textDocument/definition'] = vim.lsp.with(go_to_definition, { border = 'rounded' })
vim.lsp.handlers['textDocument/hover'] = vim.lsp.with(vim.lsp.handlers.hover, { border = 'rounded' })
vim.lsp.handlers['textDocument/signatureHelp'] = vim.lsp.with(vim.lsp.handlers.signature_help, { border = 'rounded' })

-- Disable inline diagnostics, use lsp-line instead
vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
	vim.lsp.diagnostic.on_publish_diagnostics, { virtual_text = false }
)

local capabilities = vim.lsp.protocol.make_client_capabilities()

local has_cmp_lsp, cmp_lsp = pcall(require, 'cmp_nvim_lsp')
if has_cmp_lsp then
	capabilities = vim.tbl_extend('force', capabilities, cmp_lsp.default_capabilities())
end

local M = {}

M.capabilities = capabilities
M.capabilities.textDocument.completion.completionItem.documentationFormat = { 'markdown', 'plaintext' }

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
function M.on_attach(client, bufnr)
	local function buf_set_keymap(mode, key, cmd, options)
		local opts = options and options or {}
		opts['buffer'] = bufnr
		require('utils').set_keymap(mode, key, cmd, opts)
	end

	-- Mappings.
	-- See `:help vim.lsp.*` for documentation on any of the below functions
	buf_set_keymap('n', 'gD', vim.lsp.buf.declaration)
	buf_set_keymap('n', 'gd', vim.lsp.buf.definition)
	buf_set_keymap('n', 'K', vim.lsp.buf.hover)
	buf_set_keymap('n', 'gi', vim.lsp.buf.implementation)
	buf_set_keymap('n', '<C-k>', vim.lsp.buf.signature_help)
	buf_set_keymap('n', '<space>wa', vim.lsp.buf.add_workspace_folder)
	buf_set_keymap('n', '<space>wr', vim.lsp.buf.remove_workspace_folder)
	buf_set_keymap('n', '<space>wl', function() print(inspect(vim.lsp.buf.list_workspace_folders())) end)
	buf_set_keymap('n', '<space>D', vim.lsp.buf.type_definition)
	buf_set_keymap('n', '<space>rn', vim.lsp.buf.rename)
	buf_set_keymap('n', '<space>ca', vim.lsp.buf.code_action)
	buf_set_keymap('n', 'gr', vim.lsp.buf.references)
	buf_set_keymap('n', '<space>e', vim.diagnostic.open_float)
	buf_set_keymap('n', '[d', vim.diagnostic.goto_prev)
	buf_set_keymap('n', ']d', vim.diagnostic.goto_next)
	buf_set_keymap('n', '<space>q', vim.diagnostic.setloclist)
	buf_set_keymap('n', '<space>f', function() vim.lsp.buf.format({ async = true }) end)

	if client.server_capabilities.documentFormattingProvider then
		vim.api.nvim_create_augroup('format_on_save', { clear = true })
		vim.api.nvim_create_autocmd('BufWritePre', {
			desc = 'Auto format before save',
			group = 'format_on_save',
			pattern = '<buffer>',
			callback = function()
				vim.lsp.buf.format()
			end,
		})
	end

	lsp_highlight_document(client)

	if client.server_capabilities.codeLensProvider then
		local has_virtualtypes, virtualtypes = pcall(require, 'virtualtypes')
		if has_virtualtypes then
			virtualtypes.on_attach(client, bufnr)
		end
	end
	--vim.notify(inspect(client.server_capabilities))
end

function M.config(server_name)
	local has_config, config = pcall(require, 'config.lsp.' .. server_name)
	config = has_config and config or {}
	--vim.notify(inspect(M.capabilities))
	config.on_attach = M.on_attach
	config.capabilities = M.capabilities

	return config
end

function M.setup(servers)
	servers = type(servers) == 'string' and { servers } or servers

	for _, server_name in ipairs(servers) do
		require('lspconfig')[server_name].setup(M.config(server_name))
	end
end

return M
