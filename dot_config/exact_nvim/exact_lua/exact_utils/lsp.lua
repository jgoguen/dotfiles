-- Do not edit this file directly! It is managed by chezmoi.

local Utils = require('utils')

local function lsp_highlight_document(client)
	if client.server_capabilities.documentHighlightProvider then
		vim.api.nvim_create_augroup('lsp_document_highlight', { clear = true })
		vim.api.nvim_create_autocmd('CursorHold', {
			group = 'lsp_document_highlight',
			pattern = '<buffer>',
			callback = vim.lsp.buf.document_highlight,
		})
		vim.api.nvim_create_autocmd('CursorMoved', {
			group = 'lsp_document_highlight',
			pattern = '<buffer>',
			callback = vim.lsp.buf.clear_references,
		})
	end
end

local function go_to_definition(split_cmd)
	return function(_, result, _)
		if result == nil or vim.tbl_isempty(result) then
			return nil
		end

		vim.cmd(split_cmd and split_cmd or 'vsplit')

		if vim.tbl_islist(result) then
			vim.lsp.util.jump_to_location(result[1])

			if #result > 1 then
				vim.lsp.util.set_qflist(vim.lsp.util.locations_to_items(result))
				vim.api.nvim_command('copen')
				vim.api.nvim_command('wincmd p')
			end
		else
			vim.lsp.util.jump_to_location(result)
		end
	end
end

vim.lsp.handlers['textDocument/definition'] = vim.lsp.with(go_to_definition, { border = 'rounded' })
vim.lsp.handlers['textDocument/hover'] = vim.lsp.with(vim.lsp.handlers.hover, { border = 'rounded' })
vim.lsp.handlers['textDocument/signatureHelp'] = vim.lsp.with(vim.lsp.handlers.signature_help, { border = 'rounded' })

-- Disable inline diagnostics, use lsp-line instead
vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
	vim.lsp.diagnostic.on_publish_diagnostics, { virtual_text = false }
)

local capabilities = vim.lsp.protocol.make_client_capabilities()

local has_cmp_lsp, CmpLsp = pcall(require, 'cmp_nvim_lsp')
if has_cmp_lsp then
	capabilities = vim.tbl_extend('force', capabilities, CmpLsp.default_capabilities())
end

local M = {}

M.capabilities = capabilities
M.capabilities.textDocument.completion.completionItem.documentationFormat = { 'markdown', 'plaintext' }

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
function M.on_attach(client, bufnr)
	local has_def_or_ref, def_or_ref = pcall(require, 'definition-or-references')

	-- Support toggling inlay hints
	vim.g.inlay_hints_visible = false
	local function toggle_inlay_hints()
		if vim.g.inlay_hints_visible then
			vim.g.inlay_hints_visible = false
			vim.lsp.inlay_hint(bufnr, false)
		else
			if client.server_capabilities.inlayHintProvider then
				vim.g.inlay_hints_visible = true
				vim.lsp.inlay_hint(bufnr, true)
			else
				print('No inlay hints available')
			end
		end
	end

	-- Mappings.
	-- See `:help vim.lsp.*` for documentation on any of the below functions
	Utils.buf_set_keymap('n', 'gD', vim.lsp.buf.declaration)
	if has_def_or_ref then
		Utils.buf_set_keymap('n', 'gd', def_or_ref.definition_or_references)
	else
		Utils.buf_set_keymap('n', 'gd', vim.lsp.buf.definition)
	end
	Utils.buf_set_keymap('n', 'K', vim.lsp.buf.hover)
	Utils.buf_set_keymap('n', 'gi', vim.lsp.buf.implementation)
	Utils.buf_set_keymap('n', '<C-k>', vim.lsp.buf.signature_help)
	Utils.buf_set_keymap('n', '<LocalLeader>wa', vim.lsp.buf.add_workspace_folder)
	Utils.buf_set_keymap('n', '<LocalLeader>wr', vim.lsp.buf.remove_workspace_folder)
	Utils.buf_set_keymap('n', '<LocalLeader>wl', function() print(vim.inspect(vim.lsp.buf.list_workspace_folders())) end)
	Utils.buf_set_keymap('n', '<LocalLeader>D', vim.lsp.buf.type_definition)
	Utils.buf_set_keymap('n', '<LocalLeader>rn', vim.lsp.buf.rename)
	Utils.buf_set_keymap('n', '<LocalLeader>ca', vim.lsp.buf.code_action)
	Utils.buf_set_keymap('n', 'gr', vim.lsp.buf.references)
	Utils.buf_set_keymap('n', '<LocalLeader>e', vim.diagnostic.open_float)
	Utils.buf_set_keymap(
		'n',
		'[d',
		function()
			vim.diagnostic.goto_prev()
			vim.api.nvim_feedkeys('zz', 'n', false)
		end
	)
	Utils.buf_set_keymap(
		'n',
		']d',
		function()
			vim.diagnostic.goto_next()
			vim.api.nvim_feedkeys('zz', 'n', false)
		end
	)
	Utils.buf_set_keymap(
		'n',
		'[e',
		function()
			vim.diagnostic.goto_prev({ severity = vim.diagnostic.severity.ERROR })
			vim.api.nvim_feedkeys('zz', 'n', false)
		end
	)
	Utils.buf_set_keymap(
		'n',
		']e',
		function()
			vim.diagnostic.goto_next({ severity = vim.diagnostic.severity.ERROR })
			vim.api.nvim_feedkeys('zz', 'n', false)
		end
	)
	Utils.buf_set_keymap('n', '<LocalLeader>q', vim.diagnostic.setloclist)
	Utils.buf_set_keymap('n', '<LocalLeader>f', function() vim.lsp.buf.format({ async = true }) end)
	Utils.buf_set_keymap('n', '<LocalLeader>ih', toggle_inlay_hints)
	Utils.buf_set_keymap('n', '<LocalLeader>ca', '<CMD>CodeActionMenu<CR>')

	if client.server_capabilities.documentFormattingProvider then
		vim.api.nvim_create_augroup('format_on_save', { clear = true })
		vim.api.nvim_create_autocmd('BufWritePre', {
			desc = 'Auto format before save',
			group = 'format_on_save',
			pattern = '<buffer>',
			callback = function()
				vim.lsp.buf.format()
			end,
		})
	end

	lsp_highlight_document(client)

	if client.server_capabilities.codeLensProvider then
		local has_virtualtypes, VirtualTypes = pcall(require, 'virtualtypes')
		if has_virtualtypes then
			VirtualTypes.on_attach(client, bufnr)
		end
	end
	--vim.notify(vim.inspect(client.server_capabilities))
end

---@param server_name string
function M.config(server_name)
	local has_config, Config = pcall(require, 'config.lsp.' .. server_name)
	local config = has_config and Config or {}
	--vim.notify(vim.inspect(M.capabilities))
	config.on_attach = M.on_attach
	config.capabilities = M.capabilities

	return config
end

---@param servers string|string[]
function M.setup(servers)
	servers = type(servers) == 'table' and servers or { servers }

	---@cast servers string[]
	for _, server_name in ipairs(servers) do
		require('lspconfig')[server_name].setup(M.config(server_name))
	end
end

return M
