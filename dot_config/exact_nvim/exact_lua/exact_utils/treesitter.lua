-- Do not edit this file directly! It is managed by chezmoi.

local M = {}

---@param parsers string|string[]
function M.ensure_installed(parsers)
	local has_treesitter, TSInstall = pcall(require, 'nvim-treesitter.install')
	if not has_treesitter then
		return
	end

	TSInstall.ensure_installed(parsers)
end

---@param node_types string|string[]
---@return boolean
function M.node_is(node_types, node)
	if node == nil then
		node = vim.treesitter.get_node()
		if node == nil then
			return false
		end
	end

	---@type string[]
	local types = {}
	if type(node_types) == 'string' then
		types = { node_types }
	else
		types = node_types
	end

	return vim.tbl_contains(types, node:type())
end

---@param node_types string|string[]
---@return boolean
function M.node_or_parent_is(node_types, node)
	---@type string[]
	local types = {}
	if type(node_types) == 'string' then
		types = { node_types }
	else
		types = node_types
	end

	if node == nil then
		node = vim.treesitter.get_node()
		if node == nil then
			return false
		end
	end

	repeat
		if M.node_is(types, node) then
			return true
		end

		node = node:parent()
	until node == nil

	return false
end

---@param node_types string|string[]
function M.find_node_of_type(node_types, node)
	---@type string[]
	local types = {}
	if type(node_types) == 'string' then
		types = { node_types }
	else
		types = node_types
	end

	if node == nil then
		node = vim.treesitter.get_node()
		if node == nil then
			return nil
		end
	end

	repeat
		if M.node_is(types, node) then
			return node
		end

		node = node:parent()
	until node == nil

	return nil
end

-- HTML/XML functions cursor compliments of
-- https://medium.com/scoro-engineering/5-smart-mini-snippets-for-making-text-editing-more-fun-in-neovim-b55ffb96325a
function M.html_attribute_equals()
	-- The cursor position isn't quite right, get the node to the left
	local cursor = vim.api.nvim_win_get_cursor(0)
	local range = { cursor[1] - 1, cursor[2] - 1 }
	local add_for_nodes = {
		'attribute_name',
		'directive_argument',
		'directive_name',
	}

	local node = vim.treesitter.get_node({ pos = range })
	if not node or not vim.tbl_contains(add_for_nodes, node:type()) then
		return '='
	end
	return '=""<left>'
end

function M.html_self_closing()
	local node = vim.treesitter.get_node()
	if not node then
		return '/'
	end

	local first_sibling = node:prev_named_sibling()
	if not first_sibling then
		return '/'
	end

	local parent = node:parent()
	if not parent then
		return '/'
	end

	local tag_in_progress = node:type() == 'text' and parent:type() == 'element'
	local is_start = first_sibling:type() == 'element'
	local start_text = vim.treesitter.get_node_text(first_sibling, 0)
	local is_terminated = string.match(start_text, '>$')

	if tag_in_progress and is_start and not is_terminated then
		local char = vim.fn.strcharpart(vim.fn.strpart(vim.fn.getline('.'), vim.fn.col('.') - 2), 0, 1)
		local have_space = char == ' '

		return have_space and '/>' or ' />'
	end

	return '/'
end

return M
