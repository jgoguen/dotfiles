-- Do not edit this file directly! It is managed by chezmoi.

local Utils = require('utils')

local M = {}

---@param node? TSNode
---@return TSNode?
function M.next_named_parent(node)
	if node == nil then
		node = vim.treesitter.get_node()
		if node == nil then
			return nil
		end
	end

	repeat
		node = node:parent()
	until node == nil or node:named()

	return node
end

---@param node_types string|string[]
---@param node? TSNode
---@return boolean
function M.node_is(node_types, node)
	if node == nil then
		node = vim.treesitter.get_node()
		if node == nil then
			Utils.log_immediate('No current node')
			return false
		end
	end

	---@type table<string, boolean>
	local types = {}
	if type(node_types) == 'string' then
		types[node_types] = true
	else
		for _, node_type in ipairs(node_types) do
			types[node_type] = true
		end
	end
	Utils.log_immediate(
		string.format('treesitter.node_is: Checking if node of type %s is in %s', node:type(), vim.inspect(types))
	)

	return types[node:type()] ~= nil
end

---@param node_types string|string[]
---@param node? TSNode
---@return boolean
function M.node_or_any_parent_is(node_types, node)
	if node == nil then
		node = vim.treesitter.get_node()
		if node == nil then
			return false
		end
	end

	Utils.log_immediate(
		string.format(
			'treesitter.node_or_any_parent_is: Checking if current node of type %s or any parent is in %s',
			node:type(),
			vim.inspect(node_types)
		)
	)
	repeat
		if M.node_is(node_types, node) then
			return true
		end

		node = M.next_named_parent(node)
	until node == nil

	return false
end

---@param node_types string|string[]
---@param node? TSNode
---@return boolean
function M.node_or_any_child_is(node_types, node)
	if node == nil then
		node = vim.treesitter.get_node()
		if node == nil then
			return false
		end
	end

	Utils.log_immediate(
		string.format(
			'treesitter.node_or_any_child_is: Checking if current node of type %s or any child is in %s',
			node:type(),
			vim.inspect(node_types)
		)
	)
	if M.node_is(node_types, node) then
		return true
	end

	local named_child_count = node:named_child_count()
	for i = 0, named_child_count - 1 do
		local child = node:named_child(i)
		if child ~= nil then
			require('utils').log_immediate('Node of type: ' .. child:type())
		end
		if M.node_or_any_child_is(node_types, child) then
			return true
		end
	end

	return false
end

---@param node_types string|string[]
---@param node? TSNode
---@return TSNode?
function M.find_child_of_type(node_types, node)
	if node == nil then
		node = vim.treesitter.get_node()
		if node == nil then
			return nil
		end
	end

	Utils.log_immediate(
		string.format(
			'treesitter.find_child_of_type: Checking if current node of type %s or any child is in %s',
			node:type(),
			vim.inspect(node_types)
		)
	)
	if M.node_is(node_types, node) then
		return node
	end

	local named_child_count = node:named_child_count()
	for i = 0, named_child_count - 1 do
		local child = M.find_child_of_type(node_types, node:named_child(i))
		if child ~= nil then
			return child
		end
	end

	return nil
end

---@param node_types string|string[]
---@param node? TSNode
---@return TSNode?
function M.find_parent_of_type(node_types, node)
	if node == nil then
		node = vim.treesitter.get_node()
		if node == nil then
			return nil
		end
	end

	Utils.log_immediate(
		string.format(
			'treesitter.find_parent_of_type: Checking if current node of type %s or any parent is in %s',
			node:type(),
			vim.inspect(node_types)
		)
	)
	repeat
		if M.node_is(node_types, node) then
			return node
		end

		node = M.next_named_parent(node)
	until node == nil

	return nil
end

-- HTML/XML functions cursor compliments of
-- https://medium.com/scoro-engineering/5-smart-mini-snippets-for-making-text-editing-more-fun-in-neovim-b55ffb96325a
function M.html_attribute_equals()
	-- The cursor position isn't quite right, get the node to the left
	local cursor = vim.api.nvim_win_get_cursor(0)
	local range = { cursor[1] - 1, cursor[2] - 1 }
	local add_for_nodes = {
		attribute_name = true,
		directive_argument = true,
		directive_name = true,
	}

	local node = vim.treesitter.get_node({ pos = range })
	if not node or add_for_nodes[node:type()] == nil then
		return '='
	end
	return '=""<left>'
end

function M.html_self_closing()
	local node = vim.treesitter.get_node()
	if not node then
		return '/'
	end

	local first_sibling = node:prev_named_sibling()
	if not first_sibling then
		return '/'
	end

	local parent = M.next_named_parent(node)
	if not parent then
		return '/'
	end

	local tag_in_progress = node:type() == 'text' and parent:type() == 'element'
	local is_start = first_sibling:type() == 'element'
	local start_text = vim.treesitter.get_node_text(first_sibling, 0)
	local is_terminated = string.match(start_text, '>$')

	if tag_in_progress and is_start and not is_terminated then
		local char = vim.fn.strcharpart(vim.fn.strpart(vim.fn.getline('.'), vim.fn.col('.') - 2), 0, 1)
		local have_space = char == ' '

		return have_space and '/>' or ' />'
	end

	return '/'
end

return M
