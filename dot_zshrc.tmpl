# vim: set noexpandtab tabstop=2 shiftwidth=2 autoindent:
# vim: set foldmarker=[[[,]]] foldmethod=marker foldlevel=0:
# Do not edit this file directly! It is managed by chezmoi.

if [ -z "${TERM}" ] || [ "${TERM}" = "vscode" ] || [[ ! -o interactive ]]; then
	return
fi

setopt always_to_end auto_cd auto_pushd complete_aliases complete_in_word
setopt correct extended_glob extended_history hash_list_all hist_find_no_dups
setopt hist_ignore_dups hist_ignore_space hist_no_store hist_reduce_blanks
setopt hist_save_no_dups hist_verify inc_append_history no_beep no_bg_nice
setopt no_flow_control no_hist_beep nomatch notify prompt_subst
setopt pushd_ignore_dups pushd_silent transient_rprompt

zmodload zsh/complete
zmodload zsh/complist
zmodload zsh/datetime
zmodload zsh/pcre
zmodload zsh/zutil

autoload -U add-zsh-hook
autoload -Uz colors
autoload -Uz compinit

USER_ZSH="${XDG_DATA_HOME:-"${HOME}/.local/share"}/zsh"
if [ ! -d "${USER_ZSH}/site-functions" ]; then
	mkdir -p "${USER_ZSH}/site-functions"
fi

typeset -U fpath
test -d /usr/local/share/zsh-completions && fpath=(/usr/local/share/zsh-completions ${fpath})
fpath=("${USER_ZSH}" "${USER_ZSH}/site-functions" ${fpath})

zstyle ':completion:*' ambiguous true
zstyle ':completion:*' auto-description 'specify: %d'
zstyle ':completion:*' completer _expand_alias _expand _complete _correct _approximate _ignored
zstyle ':completion:*' completions true
zstyle ':completion:*' expand prefix suffix
# format all messages not formatted in bold prefixed with ----
zstyle ':completion:*' format '%B---- %d%b'
zstyle ':completion:*' glob true
zstyle ':completion:*' group-name ''
zstyle ':completion:*' ignore-parents parent pwd directory
zstyle ':completion:*' insert-unambiguous false
zstyle ':completion:*' keep-prefix false
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' list-prompt %SAt %l: Hit TAB for more, or the character to insert%s
zstyle ':completion:*' list-suffixes true
zstyle ':completion:*' matcher-list '' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' 'r:|[._-]=* r:|=*'
zstyle ':completion:*' max-errors 1
zstyle ':completion:*' menu select
zstyle ':completion:*' original true
zstyle ':completion:*' preserve-prefix '//[^/]##/'
zstyle ':completion:*' prompt 'Corrections (%e errors)'
zstyle ':completion:*' rehash true
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' squeeze-slashes true
zstyle ':completion:*' special-dirs ..
zstyle ':completion:*' substitute 1
zstyle ':completion:*:approximate:*' max-errors 'reply=( $(( ($#PREFIX+$#SUFFIX)/3 )) numeric )'
# Don't complete the same twice
zstyle ':completion:*:complete:-command-::*' ignore-line yes
# Don't complete backup files as commands.
zstyle ':completion:*:complete:-command-::*' ignored-patterns '*\~'
zstyle ':completion:*:complete:dpkg:option--listfiles-1:*' packageset installed
zstyle ':completion:*:complete:dpkg:option--status-1:*' packageset avail
# format descriptions (notice the vt100 escapes)
zstyle ':completion:*:descriptions' format $'%{\e[0;31m%}completing %B%d%b%{\e[0m%}'
zstyle ':completion:*:sudo::' environ PATH="/usr/local/sbin:/usr/local/bin:/sbin:/usr/sbin:/bin:/usr/bin:$PATH" HOME="${HOME}"
# format in bold red error messages
zstyle ':completion:*:warnings' format "%B$fg[red]%}---- no match for: $fg[white]%d%b"

zstyle :compinstall filename "${USER_ZSH}/zcompdump"

if [ -f "${HOME}/.zcompdump" ]; then
	mv "${HOME}/.zcompdump" "${USER_ZSH}/zcompdump"
fi
compinit -d "${USER_ZSH}/zcompdump"

for f in "${USER_ZSH}"/site-functions/[a-zA-Z]*; do
	autoload -U "$(basename "${f%%.zwc}")"
done

colors

if [ -n "$ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR" ]; then
	if [ -f "${ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR}/../zsh-syntax-highlighting.zsh" ]; then
		source "${ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR}/../zsh-syntax-highlighting.zsh"
	fi
fi

# Import aliases
test -f ${HOME}/.zaliases && source ${HOME}/.zaliases

local ret_status="%(?:%{$fg_bold[green]%}:%{$fg_bold[red]%})%?%{$reset_color%}"

{{- if eq .chezmoi.os "linux" }}
if test -S ${XDG_RUNTIME_DIR:-/run/user/$(id -u)}/gnupg/S.gpg-agent ; then
	export GPG_AGENT_INFO=${XDG_RUNTIME_DIR:-/run/user/$(id -u)}/gnupg/S.gpg-agent
fi
{{- end }}

# History search with globs.
autoload -Uz narrow-to-region
_history-incremental-preserving-pattern-search-backward() {
	local state
	MARK=CURSOR	# magick, else multiple ^R don't work
	narrow-to-region -p "$LBUFFER${BUFFER:+>>}" -P "${BUFFER:+<<}$RBUFFER" -S state
	zle end-of-history
	zle history-incremental-pattern-search-backward
	narrow-to-region -R state
}
zle -N _history-incremental-preserving-pattern-search-backward
bindkey "^R" _history-incremental-preserving-pattern-search-backward
bindkey -M isearch "^R" history-incremental-pattern-search-backward
bindkey -M isearch -s ' ' '*'
bindkey "^S" history-incremental-pattern-search-forward

# Force menu on C-f.
zle -C complete-menu menu-select _generic
_complete_menu() {
	setopt localoptions alwayslastprompt
	zle complete-menu
}
zle -N _complete_menu
bindkey '^F' _complete_menu
bindkey -M menuselect '^F' accept-and-infer-next-history
bindkey -M menuselect '/' accept-and-infer-next-history
bindkey -M menuselect '^?' undo
bindkey -M menuselect ' ' accept-and-hold
bindkey -M menuselect '*' history-incremental-search-forward

# Allow to recover from C-c or failed history expansion (thx Mikachu).
_recover_line_or_else() {
	if [[ -z $BUFFER && $CONTEXT = start && $zsh_eval_context = shfunc
			&& -n $ZLE_LINE_ABORTED
			&& $ZLE_LINE_ABORTED != $history[$((HISTCMD-1))] ]]; then
		LBUFFER+=$ZLE_LINE_ABORTED
		unset ZLE_LINE_ABORTED
	else
		zle .$WIDGET
	fi
}
zle -N up-line-or-history _recover_line_or_else
_zle_line_finish() { ZLE_LINE_ABORTED=$BUFFER }
zle -N zle-line-finish _zle_line_finish

# The next line enables shell command completion for gcloud.
if [ -f '/opt/google-cloud-sdk/completion.zsh.inc' ]; then source '/opt/google-cloud-sdk/completion.zsh.inc'; fi
if [ -f '/opt/google-cloud-sdk/path.zsh.inc' ]; then source '/opt/google-cloud-sdk/path.zsh.inc'; fi

function update-env-vars() {
	renew-env SSH_AUTH_SOCK
}
add-zsh-hook preexec update-env-vars

typeset -F SECONDS
function record-start-time() {
	emulate -L zsh
	ZSH_START_TIME=${ZSH_START_TIME:-$SECONDS}
}
add-zsh-hook preexec record-start-time

# This is stolen wholesale from
# https://github.com/wincent/wincent/blob/master/roles/dotfiles/files/.zshrc
function report-start-time() {
	emulate -L zsh
	if [ $ZSH_START_TIME ]; then
		local DELTA=$(($SECONDS - $ZSH_START_TIME))
		local DAYS=$((~~($DELTA / 86400)))
		local HOURS=$((~~(($DELTA - $DAYS * 86400) / 3600)))
		local MINUTES=$((~~(($DELTA - $DAYS * 86400 - $HOURS * 3600) / 60)))
		local SECS=$(($DELTA - $DAYS * 86400 - $HOURS * 3600 - $MINUTES * 60))
		local ELAPSED=''
		test "$DAYS" != '0' && ELAPSED="${DAYS}d"
		test "$HOURS" != '0' && ELAPSED="${ELAPSED}${HOURS}h"
		test "$MINUTES" != '0' && ELAPSED="${ELAPSED}${MINUTES}m"
		if [ "$ELAPSED" = '' ]; then
			SECS="$(print -f "%.2f" $SECS)s"
		elif [ "$DAYS" != '0' ]; then
			SECS=''
		else
			SECS="$((~~$SECS))s"
		fi
		ELAPSED="${ELAPSED}${SECS}"
		export RPROMPT="exe:${ELAPSED}%f $RPROMPT_BASE"
		unset ZSH_START_TIME
	else
		export RPROMPT="$RPROMPT_BASE"
	fi
}
add-zsh-hook precmd report-start-time

# De-dup $PATH
SED_BIN="$(command -pv sed)"
if [ -n "${SED_BIN}" ]; then
	PATH=$(printf "%s" "${PATH}" | /usr/bin/awk -F ':' '{ for (i=1;i<=NF;i++) { if (!x[$i]++) printf("%s:",$i); } }' | "${SED_BIN}" 's/.$//')
fi
export PATH

STARSHIP_BIN="$(command -v starship)"
if [ -n "${STARSHIP_BIN}" ]; then
	eval $(starship init zsh)
fi

OP_BIN="$(command -v op)"
if [ -n "${OP_BIN}" ]; then
	eval $(op completion zsh)
fi

if [ -f "${HOME}/.zshrc.local" ]; then
	. "${HOME}/.zshrc.local"
fi
